package runn

import (
	"errors"
	"fmt"
	"io"
	"net/http"
	"strings"

	"github.com/Songmu/axslogparser"
	"github.com/k1LoW/curlreq"
	"github.com/k1LoW/grpcurlreq"
	"gopkg.in/yaml.v2"
)

type runbook struct {
	Desc    string          `yaml:"desc"`
	Runners yaml.MapSlice   `yaml:"runners,omitempty"`
	Steps   []yaml.MapSlice `yaml:"steps"`
}

func NewRunbook(desc string) *runbook {
	const defaultDesc = "Generated by `runn new`"
	if desc == "" {
		desc = defaultDesc
	}
	r := &runbook{Desc: desc}
	return r
}

func LoadRunbook(in io.Reader) (*runbook, error) {
	b, err := io.ReadAll(in)
	if err != nil {
		return nil, err
	}
	rb := runbook{}
	if err := yaml.Unmarshal(b, &rb); err != nil {
		return nil, err
	}
	return &rb, nil
}

func (rb *runbook) AppendStep(in ...string) error {
	if len(in) == 0 {
		return errors.New("no argument")
	}
	switch {
	case strings.HasPrefix(in[0], "curl"):
		return rb.curlToStep(in...)
	case strings.HasPrefix(in[0], "grpcurl"):
		return rb.grpcurlToStep(in...)
	default:
		if len(in) == 1 {
			if err := rb.axsLogToStep(in...); err == nil {
				return nil
			}
		}
		return rb.cmdToStep(in...)
	}
}

func (rb *runbook) curlToStep(in ...string) error {
	req, err := curlreq.NewRequest(in...)
	if err != nil {
		return err
	}

	splitted := strings.Split(req.URL.String(), req.URL.Host)
	dsn := fmt.Sprintf("%s%s", splitted[0], req.URL.Host)
	key := rb.setRunner(dsn)
	step, err := CreateHTTPStepMapSlice(key, req)
	if err != nil {
		return err
	}
	rb.Steps = append(rb.Steps, step)
	return nil
}

func (rb *runbook) grpcurlToStep(in ...string) error {
	p, err := grpcurlreq.Parse(in...)
	if err != nil {
		return err
	}
	if p.Addr == "" || p.Method == "" || p.SubCmd != "" {
		return fmt.Errorf("unsupported grpcurl command: %v", in)
	}
	dsn := fmt.Sprintf("grpc://%s", p.Addr)
	key := rb.setRunner(dsn)

	hm := yaml.MapSlice{}
	h := map[string]string{}
	for k, v := range p.Headers {
		h[k] = v[0]
	}
	if len(h) > 0 {
		hm = append(hm, yaml.MapItem{
			Key:   "headers",
			Value: h,
		})
	}

	// messages
	switch {
	case len(p.Messages) == 1:
		hm = append(hm, yaml.MapItem{
			Key:   "message",
			Value: p.Messages[0],
		})
	case len(p.Messages) > 1:
		hm = append(hm, yaml.MapItem{
			Key:   "messages",
			Value: p.Messages,
		})
	}

	if len(hm) == 0 {
		hm = nil
	}
	step := yaml.MapSlice{
		{Key: key, Value: yaml.MapSlice{
			{Key: p.Method, Value: hm},
		}},
	}
	rb.Steps = append(rb.Steps, step)
	return nil
}

func (rb *runbook) setRunner(dsn string) string {
	const (
		httpRunnerKeyPrefix = "req"
		grpcRunnerKeyPrefix = "greq"
		dbRunnerKeyPrefix   = "db"
	)
	var hc, gc, dc int
	for _, r := range rb.Runners {
		v, ok := r.Value.(string)
		if !ok {
			continue
		}
		if v == dsn {
			return r.Key.(string)
		}
		switch {
		case strings.HasPrefix(v, "http"):
			hc += 1
		case strings.HasPrefix(v, "grpc"):
			gc += 1
		default:
			dc += 1
		}
	}

	var key string
	switch {
	case strings.HasPrefix(dsn, "http"):
		if hc > 0 {
			key = fmt.Sprintf("%s%d", httpRunnerKeyPrefix, hc+1)
		} else {
			key = httpRunnerKeyPrefix
		}
	case strings.HasPrefix(dsn, "grpc"):
		if gc > 0 {
			key = fmt.Sprintf("%s%d", grpcRunnerKeyPrefix, gc+1)
		} else {
			key = grpcRunnerKeyPrefix
		}
	default:
		if dc > 0 {
			key = fmt.Sprintf("%s%d", dbRunnerKeyPrefix, dc+1)
		} else {
			key = dbRunnerKeyPrefix
		}
	}
	rb.Runners = append(rb.Runners, yaml.MapItem{Key: key, Value: dsn})
	return key
}

func (rb *runbook) axsLogToStep(in ...string) error {
	const dummyDSN = "https://dummy.example.com"
	line := strings.Join(in, " ")
	_, l, err := axslogparser.GuessParser(line)
	if err != nil {
		return err
	}
	dsn := dummyDSN
	key := rb.setRunner(dsn)
	req, err := http.NewRequest(l.Method, l.RequestURI, nil)
	if err != nil {
		return err
	}
	if l.UserAgent != "" {
		req.Header.Add("User-Agent", l.UserAgent)
	}
	step, err := CreateHTTPStepMapSlice(key, req)
	if err != nil {
		return err
	}
	rb.Steps = append(rb.Steps, step)
	return nil
}

func (rb *runbook) cmdToStep(in ...string) error {
	step := yaml.MapSlice{
		{Key: execRunnerKey, Value: yaml.MapSlice{
			{Key: "command", Value: joinCommands(in...)},
		}},
	}
	rb.Steps = append(rb.Steps, step)
	return nil
}

func joinCommands(in ...string) string {
	var cmd []string
	for _, i := range in {
		i = strings.TrimSuffix(i, "\n")
		if strings.Contains(i, " ") {
			cmd = append(cmd, fmt.Sprintf("%#v", i))
		} else {
			cmd = append(cmd, i)
		}
	}
	return strings.Join(cmd, " ") + "\n"
}
